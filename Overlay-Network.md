# 覆蓋網路（Overlay Network）

TON 的架構使得可以同時存在許多獨立的鏈 - 它們可以是私有的，也可以是公共的。節點可以選擇儲存和處理哪些分片和鏈的數據。同時，由於其通用性，數據交換協議保持不變。DHT、RLDP 和 overlay 等技術實現了這一目標。我們已經熟悉前兩個，現在讓我們來了解一下覆蓋網路。

覆蓋網路負責將單一網路分成額外的子網路。覆蓋網路可以是公共的，任何人都可以連接，也可以是私有的，需要附加的數據，只有特定人士才知道。

TON 中的所有鏈，包括主鏈，都使用它們自己的覆蓋網路進行數據交換。要加入覆蓋網路，需要找到已經加入該網路的節點，並與它們進行數據交換。可以使用 DHT 來查找這些節點。

## 與其他覆蓋網路的節點互動

我們已經在 DHT 的文章中介紹了查找覆蓋網路節點的示例，請參閱查找[儲存區塊鏈狀態的節點](https://github.com/xssnick/ton-deep-doc/blob/master/DHT.md#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BD%D0%BE%D0%B4-%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%89%D0%B8%D1%85-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B8%D0%BD%D0%B0)。在這一節中，我們將集中討論與這些節點的互動。

通過向 DHT 發送請求，我們可以獲取覆蓋網路節點的地址，這些節點可以使用 [overlay.getRandomPeers](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L237) 來查找屬於該覆蓋網路的其他節點的地址。在與足夠數量的節點建立連接之後，我們可以從它們那裡獲取有關塊和鏈的所有訊息，還可以將我們的交易發送到它們以進行處理。

### Найдем побольше соседей

Разберем пример с получением нод в оверлее.

Для этого отправим запрос `overlay.getRandomPeers`, сериализуем TL схему:
```
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;

overlay.getRandomPeers peers:overlay.nodes = overlay.Nodes;
```
`peers` - должен содержать известных нам пиров, а в случае если мы хотим принять участие в оверлее, например для обработки броадкастов, также должен содержать наш подписанный адрес, но так как мы пока никого не знаем и хотим "просто спросить", `peers.nodes` будет пустым массивом.

Запрос `overlay.getRandomPeers` является своеобразным `ping`, члены оверлея постоянно шлют его друг другу, обмениваются известными нодами и проверяют доступность друг друга. Для того чтобы быть валидным соседом, нужно поддерживать свой адрес `overlay.node` в актуальном состоянии, постоянно обновляя поле `version` текущим unix таймштампом. В случае если ваша версия устареет на более чем 10 минут, вас могут исключить из списка соседей.

Каждый запрос внутри оверлея должен иметь перфикс в виде TL схемы:
```
overlay.query overlay:int256 = True;
```
В качестве `overlay` должен быть айди оверлея - айди ключа от схемы `tonNode.ShardPublicOverlayId` - тот же, что мы использовали для поиска в DHT.

Нам нужно объединить 2 сериализованные схемы, просто соединив 2 массива байтов, `overlay.query` будет идти первым, `overlay.getRandomPeers` - вторым.

Полученный массив мы оборачиваем в схему `adnl.message.query` и отправляем по ADNL. В ответ мы ждем `overlay.nodes` - это будет список нод оверлея, к которым мы можем подключиться и, если нужно, повторить тот же запрос уже к ним, пока мы не наберем достаточное количество соединений.

### Функциональные запросы

После установки соединения, мы можем обращаться к нодам оверлея с [запросами](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L413) `tonNode.*`.

Для запросов такого рода используется протокол RLDP. И важно не забыть про префикс `overlay.query` - он должен использоваться для каждого запроса в оверлее.

В самих запросах нет ничего необычного, они очень похожи на то, что мы [делали в статье про ADNL TCP](https://github.com/xssnick/ton-deep-doc/blob/master/ADNL-TCP-Liteserver.md#getmasterchaininfo). 

Например, в запросе `downloadBlockFull` используется уже знакомый нам айди блока:
```
tonNode.downloadBlockFull block:tonNode.blockIdExt = tonNode.DataFull;
```
Передав его, мы сможем скачать полную информацию о блоке, в ответ получим:
```
tonNode.dataFull id:tonNode.blockIdExt proof:bytes block:bytes is_link:Bool = tonNode.DataFull;
  или
tonNode.dataFullEmpty = tonNode.DataFull;
```
В случае наличия, в поле `block` будут данные в формате TL-B. 

Таким образом мы можем получать информацию напрямую от нод.

## Broadcasts - распространение информации по сети

В некоторых оверлеях, где состояние сети непостоянно и может изменяться, используется протокол броадкастов. Он отвечает за передачу данных к соседним пирам, каждый пир, получив и обработав броадкаст сообщение, пересылает его своим соседям, которых может быть до пяти. Таким образом, передав изначальное сообщение нескольким пирам, оно распространится по всей сети.

Протокол броадкастов работает поверх ADNL UDP, используя [*Custom*](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L133) сообщения в контексте оверлея, и активно применяется в сетях шардчеинов для распространения новых блоков от валидаторов ко всем нодам, а также для распространения external сообщений от нод сети к валидаторам.

##### Броадкасты делятся на несколько типов:
* [**Обычный**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L236) - c помощью сообщений данного типа по сети распространяются небольшие данные, например, external сообщения от пользователей. Часто не требует специальных разрешений.

* [**FEC**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L237) - Тип броадкаст сообщения, использующийся для распространения больших данных, например, новых блоков. Работает по принципу RLDP, может состоять из большого количества частей, и для упаковки данных используется алгоритм RaptorQ, как и в RLDP, но по завершению получения нам нужно ответить [overlay.fec.completed](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L220).
 
* [**FEC Short**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L239) - Аналогично предыдущему, но не несет в себе самих данных, передавая только их хеш, позволяет оптимизировать нагрузку на сеть, так как данные не гоняются туда-сюда повторно. Если пир еще не знает про полученный хеш, он запросит данные у ноды, от которой получил сообщение. На практике его применение пока не встречал.

### Права доступа к броадкастингу

Оверлеи могут иметь разные разрешения, инициация броадкаста может быть разрешена только определенному кругу нод, например, валидаторам. Каждому члену сети заранее известен список доверенных публичных ключей, например, в случае шардчеинов - доверенные айди ключей хранятся в конфиге сети, в параметрах 32-37 включительно - это списки прошлых, текущих и следующих валидаторов. Основной список обновляется каждый раунд, и не все ключи конфига могут существовать одновременно.

Каждый участник сети при получении броадкаста валидирует его. Для определения происхождения используются поля `src:PublicKey` и `certificate:overlay.Certificate`. Сначала проверяется наличие айди от ключа `src` в списке доверенных. Если айди есть в списке - ключ считается валидным. Если ключа нет - мы проверяем сертификат `certificate`. 

Для преобразования `PublicKey` в айди ключа мы берем [sha256 хеш от его сериализованной схемы](https://github.com/xssnick/ton-deep-doc/blob/master/ADNL-TCP-Liteserver.md#%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D0%B9%D0%B4%D0%B8-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0).

#### Проверка сертификата броадкаста

Сертификат может быть нескольких видов:
* [**overlay.certificate**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L228) - Стандартный тип сертификата, без настроек, разрешает все виды броадкаста, но может ограничивать размер сообщения параметром `max_size`

* [**overlay.certificateV2**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L229) - Расширенный тип сертификата, позволяет ограничивать виды броадкаста (запретить FEC) и контролировать уровень доверия (trusted/need check) благодаря наличию параметра `flags`.

* [**overlay.emptyCertificate**](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L230) - Сертификат отсутствует, если первичная проверка броадкаста на ключ не пройдена - броадкаст считается невалидным и игнорируется.

Для проверки сертификата нам нужно сначала проверить кто его выдал, для этого мы читаем поле `issued_by:PublicKey` сертификата и проверяем, есть ли в списке доверенных такой айди ключа. Если есть, мы проверяем подпись сертификата, сериализуя его по [схеме в зависимости от типа](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L232), где в качестве node указываем айди ключа, для которого выдан сертификат, т.е айди от `src:PublicKey` из сообщения броадкаста. Если подпись совпала, сертификат можно считать доверенным и относиться к ключу `src` как к тому, кто выдал сертификат, но с учетом ограничений, указаных в сертификате.

#### Проверка подписи броадкаста

После того, как ключ и сертификат прошли проверку, нам нужно проверить подпись самого сообщения броадкаста на соответствие ключу из поля `src`. Для этого нам сначала нужно вычислить айди броадкаста, им будет являться [айди схемы broadcast.Id нужного типа броадкаста](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L222-L223). В поле `src` нам нужно указать айди ключа, посчитанный из ключа `src` самого броадкаста. Для типа FEC присутствует еще поле `type` - это айди от FEC типа, поля `fec` из схемы броадкаста. После того, как мы заполнили структуру, мы берем от нее айди (хеш), это и будет являться айди нашего броадкаста.

Если тип нашего броадкаста - FEC, нам нужно еще посчитать айди его части, сериализовав структуру [overlay.broadcastFec.partId](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L224), в качестве `data_hash` нужно использовать sha256 хеш от поля `data` полученной части броадкаста.

Далее нам нужно сериализовать схему [overlay.broadcast.toSign](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L226), где в качестве `hash` передать айди его части (посчитанный выше) в случае FEC, а в случае обычного броадкаста - просто хеш от поля `data`. В поле `date` нужно записать время броадкаста, полученное в сообщении в одноименном поле. 

После сериализации схемы нам остается только сравнить ее подпись относительно ключа. Если подпись верна, броадкаст можно считать принятым, отправлять соседям и обрабатывать у себя.

#### Содержимое броадкастов у шардчеинов

В броадкастах шардчеинов передаются новые блоки (как мастерчеина, так и бейзчеина) и экстернал сообщения от пользователей.

[[Используемые схемы]](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L392-L397)

Например, внутри такой структуры как `tonNode.blockBroadcast`, в поле `data` содержится сериализованый Cell [TL-B схемы блока](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L446), обработка которого уже может зависить от конкретной цели. 

Обработка броадкастов уже зависит от конкретной цели, но важно помнить, что недостаточно их просто читать, **нужно распространять их по соседям для обеспечения стабильности сети**.
